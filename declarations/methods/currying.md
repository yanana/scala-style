複数のパラメータリスト
======================

一般に，そうする理由があるときにだけ複数のパラメータリストを使うべきです。複数のパラメータリストを持つメソッドや関数は，
宣言も呼び出し側のコードも冗長になり，経験の少ない開発者にとっては判り辛くなります。

複数のパラメータリストを使うべき主な理由が3つあります。

1.  流れるようなインターフェース

<!-- -->

1.  暗黙のパラメータ

> `implicit`キーワードを使って暗黙のパラメータを使っているとき，全てのパラメータリストにその効果が適用されます。
> このため，あるパラメータだけをimplicitにしたい場合は複数のパラメータリストを使用する必要があります。

1.  型推論のため

> パラメータリストの一部だけ使ってメソッドを呼び出す時，型推論によって残りのパラメータリストをシンプルにすることができます。
> foldを例に考えてみましょう。 :
>
>     def foldLeft[B](z:B)(op: (A,B) => B):B
>     List("").foldLeft(0)(_ + _.length)
>
>     // 代わりにこうすると，
>     def foldLeft[B](z: B, op: (B, A) => B): B
>     // 上記の呼び出しはうまくいかず，型を明記しないといけない
>     List("").foldLeft(0, (b: Int, a: String) => a + b.length)
>     List("").foldLeft[Int](0, _ + _.length)

複雑なDSLや長い型名を扱うとき，宣言を1行に収めるのが難しくなります。こういう場合には，パラメータリストを1行毎に
揃えます（i.e. 1行に収められないときは，1行に1つずつ配置します）。 :

    protected def forResource(resourceInfo:Any)
                             (f: (JsonNode) => Any)
                             (implicit urlCreator: URLCreator, configurer: OAuthConfiguration) = {
